AI 支持
openrouter
API：sk-or-v1-
20822b65da2fa12acc3f8035ea2f1a6e9803d9bdaec6e905a7896708ca3e5
846
大模型（ai 对话功的能时候可以进行大模型的切换）：
openai/gpt-5
deepseek/deepseek-chat-v3.1
google/gemini-2.5-flash
google/gemini-2.5-pro
anthropic/claude-sonnet-4
备用 kimi k2
AIP:sk-ZAHmFT4sGdezYpw8ubhJjI0huFJgjDlC3JW7X9OgpJmBb0UY
### **1. 项目/功能概述 (Overview)**
**项目名称：** AI 智能笔记 (AI Smart Notes) - V1.0
**核心目标：** 开发一个桌面端笔记应用。用户可以自由书写笔记，并在保存时，由
AI 自动推荐分类、文件夹和标签，经用户确认后进行归档。同时，提供 AI 辅助的文
本润色功能，提升写作质量。
### **2. 核心功能点 (Core Features)**
1. **分层级笔记组织：** 笔记将按照 `分类 > 文件夹 > 笔记` 的三层结构进行组织。
* **分类 (Category):** 固定的三个顶层分类：“工作”、“学习”、“生活”。
* **文件夹 (Folder):** 用户可以在每个分类下创建任意文件夹。
* **笔记 (Note):** 存储在具体的文件夹内。
2. **动态标题：** 笔记的标题默认采用其内容的第一行，但用户可以随时手动修改为
一个独立的标题。
3. **AI 智能归档 (核心功能):**
* 在保存笔记时，AI 会分析笔记内容。
* 系统弹窗向用户建议一个**分类**、一个**文件夹名称**（可以是新的或已有
的）以及若干个**标签 (Tags)**。
* 用户可以接受 AI 的建议，也可以在弹窗中直接修改，然后确认保存。
4. **AI 辅助润色:**
* **全文润色:** 编辑器中提供一个“全文润色”按钮，点击后 AI 会对整篇笔记
内容进行优化和修正。

--- PAGE 1 ---

* **划词润色 (V1.1 规划):** 在编辑器中选中文字后，出现一个快捷菜单，提供
“润色”选项。（*专家建议：我们先实现全文润色，这个功能更容易，后续再添加划
词润色*）。
5. **基础笔记管理：** 提供创建、查看、编辑和删除笔记的基本功能。
### **3. 技术规格 (Technical Specifications)**
#### **前端 (Frontend)**
* **页面/组件 (Pages/Components):**
* `NotesPage.vue`: 应用主界面，采用经典的三栏布局。
* `Sidebar.vue` (左栏): 以树状结构展示 `分类 > 文件夹 > 笔记列表`。
* `NoteEditor.vue` (中栏/右栏): 笔记的编辑区域，包含文本输入框、标题输入框、
以及“全文润色”和“AI 保存”按钮。
* `AISuggestionModal.vue` (弹窗组件): 当用户点击“AI 保存”后，弹出此窗口，
显示 AI 建议的分类、文件夹和标签，并提供给用户修改和确认的选项。
* **用户流程 (User Flow - 创建新笔记):**
1. 用户点击“新建笔记”按钮。
2. `NoteEditor.vue` 显示空白状态。
3. 用户开始输入内容。第一行文本自动被识别为笔记的（临时）标题。用户也可
以手动在标题框内输入。
4. *(可选)* 用户点击“全文润色”，前端将当前笔记内容发送给后端，并将返回
的润色后内容更新到编辑器中。
5. 用户点击“AI 保存”按钮。
6. 前端将笔记的**标题和内容**发送到后端的分析接口（例如 `POST
/api/ai/analyze-note`）。
7. 后端返回 AI 的分析结果：`{ "category": "学习", "folder": "Python 编程", "tags":
["异步", "教程"] }`。
8. `AISuggestionModal.vue` 弹出，并将这些建议填充到对应的选择框和输入框
中。
9. 用户检查建议，可直接点击“确认保存”，或修改后再确认。
10. 前端将最终的笔记数据（标题、内容、分类 ID、文件夹名称、标签列表）发
送到后端的创建接口（例如 `POST /api/notes`）。
11. 保存成功后，`Sidebar.vue` 刷新，在正确的分类和文件夹下显示出这篇新笔
记。
* **数据交互 (Data Interaction):**
* 向后端请求所有笔记的层级结构（`GET /api/notes-tree`）用于渲染侧边栏。
* 向后端发送笔记内容进行润色（`POST /api/ai/polish-text`）。
* 向后端发送笔记内容进行分析（`POST /api/ai/analyze-note`）。

--- PAGE 2 ---

* 向后端发送完整数据以创建/更新笔记（`POST /api/notes`, `PUT
/api/notes/{id}`）。
#### **后端 (Backend)**
* **API 接口 (API Endpoints):**
* **AI 服务接口:**
* `POST /api/ai/polish-text`: (用于文本润色)
* 请求: `{ "text": "我今天学习 python。" }`
* 响应: `{ "polished_text": "今天，我学习了 Python 编程语言。" }`
* `POST /api/ai/analyze-note`: (用于分析内容并建议归档路径)
* 请求: `{ "title": "...", "content": "..." }`
* 响应: `{ "category": "学习", "folder": "Python 编程", "tags": ["异步", "教
程"] }`
* **笔记管理接口 (CRUD):**
* `GET /api/notes-tree`: 获取所有笔记的树状结构数据，方便前端渲染。
* `POST /api/notes`: 创建一个新笔记。
* `PUT /api/notes/{id}`: 更新一个已存在的笔记。
* `DELETE /api/notes/{id}`: 删除一个笔记。
* **数据模型 (Data Models):**
* `Category` (分类表): `id`, `name` (例如: "工作", "学习", "生活")
* `Folder` (文件夹表): `id`, `name`, `category_id` (外键，关联到 `Category` 表)
* `Note` (笔记表): `id`, `title`, `content` (存储 Markdown 或 HTML), `folder_id`
(外键，关联到 `Folder` 表)
* `Tag` (标签表): `id`, `name`
* `Note_Tags` (中间表): `note_id`, `tag_id` (用于建立笔记和标签的多对多关系)
### **4. 技术栈建议 (Tech Stack Suggestion)**
* **前端:** **Vue.js 3** + **TipTap** (一个基于 Prosemirror 的现代富文本编辑器库，
它非常灵活，未来添加“划词润色”会很方便)。
* **后端:** **Python** + **FastAPI** (Python 是调用 AI 的最佳语言，FastAPI 简单、
高效)。
* **数据库:** **SQLite** (项目初期最简单的选择，就是一个文件，无需安装和配置)。
* **AI 服务:** **OpenAI API** (你需要注册一个账号并获取 API Key，使用 `gpt-3.5-
turbo` 模型在成本和效果上是个不错的开始)。
### **5. 开发步骤建议 (Development Steps)**
为了避免一开始就陷入 AI 的复杂性中，我建议我们分三步走：

--- PAGE 3 ---

* **第一步：构建一个“笨笨的”但功能完整的笔记应用 (无 AI)**
1. **环境搭建：** 初始化 Vue.js 前端项目和 FastAPI 后端项目。
2. **数据库与后端 API：** 使用 SQLAlchemy ORM 定义数据模型，并创建
SQLite 数据库。编写笔记的增、删、改、查 (CRUD) API，在这一步，让用户**手动
选择**分类和文件夹来保存笔记。
3. **前端基础界面：** 搭建出侧边栏和编辑器的基本布局。让侧边栏能显示笔记
列表，编辑器能创建和修改笔记内容，并能手动保存。
* **🎯 里程碑:** 完成这一步后，你就拥有一个可以正常使用的本地笔记软件了！
这是建立信心的关键。
* **第二步：给应用装上“AI 大脑”**
1. **后端集成 OpenAI：** 在后端项目中安装 `openai` 库，配置你的 API Key。
编写一个可以调用 OpenAI 接口的公共函数。
2. **实现 AI 接口：** 重点开发 `POST /api/ai/analyze-note` 和 `POST
/api/ai/polish-text` 这两个接口。你需要精心设计发送给 AI 的“提示语 (Prompt)”来获
得期望的 JSON 格式输出。
3. **前端连接 AI：** 在前端添加“全文润色”按钮，并让它调用后端接口，体验
第一个 AI 功能！
* **第三步：实现“智能保存”的完整流程**
1. **创建建议弹窗：** 在前端开发 `AISuggestionModal.vue` 组件。
2. **改造保存流程：** 将原有的“保存”按钮改为“AI 保存”，并实现我们上面
设计的【用户流程】，完成从分析到确认的完整闭环。
3. **打磨与优化：** 完善 UI 细节和交互体验。
太棒了！你的回答非常清晰，充满了激动人心的想法。你不仅确认了我的问题，还提
出了“日历挂钩”这个极具价值的新功能。这正是专家与需求方之间最好的互动！
我们现在有了一个非常明确的方向：我们要构建一个以**看板（Kanban）**和**日历
（Calendar）**为双核心视图，并由**AI 自然语言创建**功能驱动的智能待办事项
（To-Do）模块。
现在，我将为你整理一份完整的技术需求文档。
---
### **1. 项目/功能概述 (Overview)**
**项目名称：** Cortex AI 工作区 - 智能待办模块 (To-Do Module) - V1.0
**核心目标：** 开发一个强大的待办事项管理工具。用户可以通过看板视图管理任务
流程，通过日历视图直观了解日程安排。其核心亮点是通过自然语言快速创建任务，
并由 AI 辅助进行分类。

--- PAGE 4 ---

### **2. 核心功能点 (Core Features)**
1. **AI 驱动的快速创建：**
* **自然语言解析：** 用户可在单一输入框中输入如“下周三下午三点开项目启
动会，优先级高”的文本。
* **智能提取：** AI 自动解析并填充任务的标题、截止时间、优先级等信息。
* **智能分类：** AI 会根据任务内容，自动建议归入“工作”、“学习”或“生
活”分类。
2. **双视图任务管理：**
* **看板视图 (Kanban View):** 以“待处理 (To-Do)”、“进行中 (Doing)”、“已
完成 (Done)”等列来组织任务卡片，支持拖拽任务来改变状态。
* **日历视图 (Calendar View):** 在月/周/日视图中展示所有带日期的任务，让日
程安排一目了然。
3. **丰富的任务属性：**
* **时间：** 开始时间 和 截止时间（精确到小时和分钟）。
* **优先级 (Priority):** 高、中、低（在界面上用不同颜色标记）。
* **状态 (Status):** 待处理、进行中、已完成。
* **分类 (Category):** 工作、学习、生活。
4. **基础任务操作 (CRUD):** 支持对任务进行创建、查看、编辑和删除。
5. **提醒功能 (V1.1 规划):**
* 可以为任务设置“提前 X 分钟/小时提醒”。
* **(专家建议：这是一个非常棒但相对复杂的功能，因为它涉及到与操作系统
层面的通知系统交互。为了让 V1.0 版本能快速上线，建议我们先在数据模型里预留好
字段，但将发送通知的逻辑放入 V1.1 版本开发。V1.0 我们先专注于核心的任务创建
和管理流程。)**
### **3. 技术规格 (Technical Specifications)**
#### **前端 (Frontend)**
* **页面/组件 (Pages/Components):**
* `TodoPage.vue`: 主页面，包含一个切换按钮，用于在 `KanbanBoard.vue` 和
`CalendarView.vue` 之间切换。
* `AITaskInput.vue`: 位于页面顶部的“智能输入框”，用于接收用户的自然语
言指令。
* `KanbanBoard.vue`: 看板视图的容器。
* `KanbanColumn.vue`: 代表一个状态列（如“待处理”）。
* `TaskCard.vue`: 代表一个可拖拽的任务卡片，会根据优先级显示不同颜
色的边框。
* `CalendarView.vue`: 日历视图的容器，用于展示任务。

--- PAGE 5 ---

* `TaskDetailModal.vue`: 点击任务卡片时弹出的模态框，用于查看和编辑任务
的所有详细信息（开始/结束时间、优先级等）。
* **用户流程 (User Flow - AI 创建任务):**
1. 用户在 `AITaskInput.vue` 中输入：“提醒我明天下午 2 点到 4 点准备周会
PPT，工作类，很重要”。
2. 用户按回车键。前端将这句纯文本发送到后端的 AI 解析接口 (`POST
/api/ai/parse-task`)。
3. 后端 AI 服务返回一个结构化的 JSON 对象，例如：
```json
{
"title": "准备周会 PPT",
"start_time": "2023-10-28T14:00:00",
"end_time": "2023-10-28T16:00:00",
"category": "工作",
"priority": "high"
}
```
4. 前端接收到这个 JSON 对象后，调用创建任务的接口 (`POST /api/tasks`)，将
这些信息发送给后端进行保存。
5. 保存成功后，`KanbanBoard.vue` 的“待处理”列中出现一张新的高优先级任
务卡，同时 `CalendarView.vue` 在明天的对应时间段也会显示这个任务。
#### **后端 (Backend)**
* **API 接口 (API Endpoints):**
* **AI 服务接口:**
* `POST /api/ai/parse-task`: (用于解析自然语言创建任务)
* 请求: `{ "text": "明天下午 2 点开会" }`
* 响应: (如上所示的结构化 JSON)
* **任务管理接口 (CRUD):**
* `GET /api/tasks`: 获取所有任务，可以带参数筛选（如 `?date_range=...`
或 `?category=...`）。
* `POST /api/tasks`: 创建一个新任务。
* `PUT /api/tasks/{id}`: 更新一个任务。这非常重要，例如当用户在看板上
拖动卡片时，前端会调用此接口来更新任务的 `status` 字段。
* `DELETE /api/tasks/{id}`: 删除一个任务。
* **数据模型 (Data Models):**
* `Category` (分类表): 我们可以**复用之前为笔记模块设计的分类表**！包含
`id` 和 `name`。
* `Task` (任务表):

--- PAGE 6 ---

* `id`: 主键
* `title`: 字符串 (任务标题)
* `description`: 文本 (更详细的描述，可选)
* `start_time`: 日期时间 (DateTime)
* `end_time`: 日期时间 (DateTime)
* `priority`: 字符串 (枚举类型: 'low', 'medium', 'high')
* `status`: 字符串 (枚举类型: 'todo', 'doing', 'done')
* `category_id`: 外键 (关联到 `Category` 表)
* `reminder_minutes_before`: 整数 (为 V1.1 的提醒功能预留的字段)
### **4. 技术栈建议 (Tech Stack Suggestion)**
* **前端:** **Vue.js 3**
* **看板拖拽库:** 推荐使用 **`vuedraggable`**，它能非常方便地实现拖拽功能。
* **日历库:** 推荐使用 **`FullCalendar.io`** 的 Vue 组件，这是业内功能最强大、
最专业的日历组件库。
* **后端:** **Python** + **FastAPI**
* **数据库:** **SQLite**
* **AI 服务:** **OpenAI API**
### **5. 开发步骤建议 (Development Steps)**
这个功能比笔记要复杂，我们更要分步走，确保每一步都有成果。
* **第一步：后端基础建设 (无 AI)**
1. **数据库模型：** 在后端项目中定义 `Task` 数据模型，并生成数据库表。
2. **核心 API：** 编写任务的增、删、改、查 (CRUD) API。确保 `GET
/api/tasks` 和 `PUT /api/tasks/{id}` 能够正常工作。
* **第二步：前端静态视图 (无 AI, 无交互)**
1. **搭建基础布局：** 创建 `TodoPage.vue`，并添加视图切换按钮。
2. **静态看板：** 开发 `KanbanBoard.vue`，从后端获取任务数据并**静态地**
渲染在“待处理”、“进行中”、“已完成”三列中。此时任务卡片还不能拖动。
3. **集成日历：** 集成 `FullCalendar` 组件，让它能够获取并展示 `GET
/api/tasks` 的数据。
* **🎯 里程碑:** 完成后，你就有了一个可以查看任务的看板和日历了，这是可
视化的关键一步！
* **第三步：实现核心交互与 AI**
1. **看板拖拽功能：** 使用 `vuedraggable` 库改造 `KanbanBoard.vue`，实现任
务卡片的拖拽。当拖拽完成时，调用 `PUT /api/tasks/{id}` 接口更新任务状态。
2. **后端 AI 解析器：** 集中精力开发 `POST /api/ai/parse-task` 接口。这是最
有趣的部分，你需要设计一个绝佳的 Prompt (提示词) 来让 AI 精准地返回我们需要的

--- PAGE 7 ---

JSON 格式。
3. **前端智能输入框：** 开发 `AITaskInput.vue` 组件，实现我们设计的“自然
语言创建任务”用户流程。
* **第四步：完善与打磨**
1. **细节开发：** 实现 `TaskDetailModal.vue` 弹窗，用于编辑任务的全部详情。
2. **视觉优化：** 根据任务的 `priority` 属性，为 `TaskCard.vue` 添加不同颜色
的样式。
---
---
### **1. 项目/功能概述 (Overview)**
**项目名称：** Cortex AI 工作区 - 智能对话模块 (AI Chat Module) - V1.0
**核心目标：** 开发一个集成在工作区中的、上下文感知的 AI 助理。它以浮动侧边栏
的形式常驻，不仅能进行通用问答和内容创作，还能理解并执行用户的指令，直接操
作和管理用户的笔记与待办事项，成为连接所有模块的“智能中枢”，真正实现“第
二大脑”的构想。
### **2. 核心功能点 (Core Features)**
1. **私人工作区助理 (Workspace Assistant):**
* **核心能力:** AI 能够访问和理解用户在“笔记模块”和“待办模块”中的数
据。
* **应用场景:** 用户可以提问，如：“帮我找出上周所有关于‘市场分析’的
笔记”、“我今天还有哪些任务没完成？”。
* **扩展能力:** 同时具备通用知识问答（如“解释什么是 API”）和内容创作
（如“帮我写一封邮件”）的能力。
2. **指令式操作 (Conversational Control):**
* **自然语言指令:** 用户可以直接用自然语言下达指令，让 AI 创建或修改数据。
* **交互式创建:** 当指令信息不完整时（如 “提醒我明天开会”），AI 会主动
反问以补全信息（如 “好的，会议是几点开始？需要设置什么优先级吗？”），然后
执行创建。
* **对话转笔记:** 提供“一键将当前对话总结并存为笔记”的功能。
3. **多主题对话管理 (Session-based Management):**
* 用户可以创建多个独立的对话“会话”（Session），每个会话有自己的上下
文。
* 例如，一个会话用于“项目 A 头脑风暴”，另一个用于“周报撰写”，避免信
息混淆。

--- PAGE 8 ---

* 所有会话列表清晰可见，方便随时切换和回顾。
4. **全局浮动侧边栏 (Global Floating Sidebar):**
* 对话界面以一个可随时展开/收起的侧边栏形式存在，不打断用户在笔记或待
办页面的主要工作流。
5. **上下文关联互动 (Context-Aware Interaction):**
* **一键存为笔记:** AI 的任何一条重要回复旁边都有一个按钮，可快速将其内
容存为一篇新笔记。
* **一键创建待办:** 当 AI 生成一个步骤列表或行动项时，可一键将其批量转化
为待办任务。
* **关联上下文对话:** 用户在查看某篇笔记或某个待办时，可以发起一个“与
此相关”的对话，AI 会自动将当前项目作为上下文进行理解和讨论。
### **3. 技术规格 (Technical Specifications)**
#### **前端 (Frontend)**
* **页面/组件 (Pages/Components):**
* `AIChatSidebar.vue`: 核心组件，作为全局浮动侧边栏的容器。它管理着整个
对话功能的状态。
* `SessionList.vue`: 在侧边栏内部，用于展示和切换不同对话会话的列表。
* `ChatWindow.vue`: 显示当前会话的所有消息气泡。
* `MessageBubble.vue`: 单条消息的组件，需要区分“用户消息”和“AI 消
息”的样式。
* `ActionButtons.vue`: 附加在 `MessageBubble` (AI 消息) 旁边的按钮组（如
“存为笔记”）。
* **用户流程 (User Flow - 指令式创建待办):**
1. 用户在 `AIChatSidebar.vue` 中输入：“下周一上午 10 点提醒我开产品会”。
2. 前端将此文本和当前 `session_id` 发送到后端核心接口 `POST
/api/chat/command`。
3. 后端 AI 判断这是一个“创建任务”指令，且信息完整。它不直接操作数据库，
而是返回一个结构化的 JSON：
```json
{
"response_type": "action",
"action_details": {
"type": "create_task",
"params": {
"title": "开产品会",
"start_time": "2023-11-06T10:00:00",
"priority": "medium"
}
},
"display_message": "好的，我已经为您安排了下周一上午 10 点的产品会提

--- PAGE 9 ---

醒。"
}
```
4. 前端收到此 JSON 后，解析 `response_type`。发现是 `action`。
5. 根据 `action_details.type` (`create_task`)，前端调用**已有的** `POST
/api/tasks` 接口，并将 `params` 作为请求体发送。
6. 最后，前端在 `ChatWindow.vue` 中显示 AI 的 `display_message`。
* **(专家注：这种“后端发指令，前端执行”的模式是一种非常优雅和安全的
设计。它让聊天接口专注于理解和决策，而数据的实际操作则复用我们已经写好的、
稳定的 CRUD 接口，权责分明。)**
#### **后端 (Backend)**
* **API 接口 (API Endpoints):**
* **核心对话接口 (Brain):**
* `POST /api/chat/command`: 这是整个功能的大脑。接收用户输入、对话
历史、以及可能的上下文（如当前正在看的笔记 ID），然后与 AI 模型 交互，决定是
普通回复，还是返回一个 `action` JSON。
* **会话管理接口:**
* `GET /api/chat/sessions`: 获取所有对话会话的列表。
* `POST /api/chat/sessions`: 创建一个新的空会话。
* `GET /api/chat/sessions/{id}/messages`: 获取某个特定会话的所有历史消
息。
* **数据模型 (Data Models):**
* `ChatSession` (对话会话表):
* `id`: 主键
* `title`: 字符串 (会话标题，如“周报构思”)
* `user_id`: 外键 (关联用户)
* `created_at`: 创建时间
* `ChatMessage` (对话消息表):
* `id`: 主键
* `session_id`: 外键 (关联到 `ChatSession`)
* `role`: 字符串 (枚举: 'user', 'ai')
* `content`: 文本 (消息内容)
* `created_at`: 创建时间
### **4. 技术栈建议 (Tech Stack Suggestion)**
* **前端:** **Vue.js 3** + **Pinia** (Pinia 是一个状态管理库，非常适合管理像“AI
侧边栏是否展开”这样的全局状态)。
* **后端:** **Python** + **FastAPI**

--- PAGE 10 ---

* **数据库:** **SQLite** (或 PostgreSQL)
* **AI 服务:** **OpenAI API (GPT-4 或 GPT-3.5-turbo)** (它们的“Function Calling”
功能非常适合实现我们设计的指令式操作)。
### **5. 开发步骤建议 (Development Steps)**
这个模块非常强大，但我们可以把它拆成小块来逐一攻克。
1. **第一步：后端数据结构先行**
* 创建 `ChatSession` 和 `ChatMessage` 的数据库模型。
* 编写用于管理会话和消息的基础 API（创建会话、获取会话列表、获取消息历
史）。
2. **第二步：前端静态界面搭建**
* 使用假数据，开发 `AIChatSidebar.vue`, `SessionList.vue`,
`ChatWindow.vue`。目标是让界面看起来像一个真正的聊天应用，但此时发送消息没
有任何效果。
3. **第三步：实现基本对话循环 (无指令)**
* 打通前后端。让前端能够调用 `POST /api/chat/command`，后端接收到后，
简单调用 OpenAI API 做一次问答，然后将结果返回并显示。
* **🎯 里程碑:** 完成后，你就拥有了一个集成在你的应用里的、可以多会话的
ChatGPT 翻版！
4. **第四步：“指令控制”核心功能开发**
* 这是最具挑战性的一步。重点改造后端的 `POST /api/chat/command` 接口。
* 设计一个复杂的 Prompt (提示词)，指导 AI 模型在识别到用户指令时，返回我
们预设的 `action` JSON 格式。
* 在前端开发解析这个 `action` JSON 并调用相应 API（如 `POST /api/tasks`）
的逻辑。
5. **第五步：集成上下文与互动按钮**
* 实现“关联上下文对话”功能：当用户在笔记页发起对话时，前端将笔记内容
一并传给后端。
* 为 AI 的消息气泡添加 "存为笔记" 等 `ActionButtons`，并实现其功能。
---
### **1. 项目/功能概述 (Overview)**
**项目名称：** Cortex AI 工作区 - 专注番茄钟模块 (Focus Pomodoro Module) - V1.0
**核心目标：** 在工作区中集成一个高度可定制的番茄钟，它既可以作为全局小部件
常驻，也能进入沉浸式的“专注模式”。该功能允许用户灵活地将其与待办任务关联，
通过记录专注时长来量化工作，并通过多种提醒和主题化界面，提升用户的工作效率

--- PAGE 11 ---

和体验。
### **2. 核心功能点 (Core Features)**
1. **可定制的时间周期:**
* 提供业界标准的默认时间设置（如工作 25 分钟 / 短休 5 分钟 / 长休 15 分钟）。
* 用户可以在设置面板中自由修改所有时间周期的时长。
2. **双模界面 (Dual-Mode UI):**
* **全局小部件 (Global Widget):** 在应用的固定位置（如导航栏）显示一个迷
你计时器，方便用户随时查看状态。
* **专注模式 (Focus Mode):** 点击小部件可进入一个全屏、无干扰的界面，中
央有大尺寸的倒计时和控制按钮。
3. **情绪化主题选择:**
* 在“专注模式”下，用户可以选择不同的主题（如不同的背景色、背景图片甚
至白噪音），以适应不同的工作心境，满足“情绪价值”。
4. **可选的待办任务关联:**
* 用户可以直接启动一个独立的番茄钟，无需关联任何任务。
* 用户也可以在“待办事项”列表中，针对某一特定任务“开启专注”，计时器
将与该任务绑定。
5. **专注数据统计:**
* 系统会记录完成某个特定任务所花费的“番茄钟”数量。
* 未来可以基于此数据生成工作报告，帮助用户复盘。
6. **多渠道提醒:**
* **声音提醒:** 在番茄钟或休息时间结束时，播放提示音。
* **桌面通知:** 利用浏览器功能，在用户切到其他窗口时也能收到桌面推送提
醒。
7. **自动流转（可选）:**
* 用户可以在设置中开启“自动流转”功能，当一个工作番茄钟结束后，计时器
会自动开始短休息倒计时。
### **3. 技术规格 (Technical Specifications)**
#### **前端 (Frontend)**
* **页面/组件 (Pages/Components):**
* `PomodoroWidget.vue`: 全局迷你小部件，显示倒计时和核心控制（开始/暂
停）。
* `FocusView.vue`: 全屏专注模式页面，包含大倒计时、主题背景和完整的控制
按钮（开始/暂停/重置/跳过）。
* `PomodoroSettings.vue`: 设置面板，用于修改时长、选择主题、开关自动流
转等。

--- PAGE 12 ---

* `TaskItem.vue` (**修改**): 在待办事项组件中，需要新增一个“开始专注”的
按钮。
* **状态管理 (State Management - 使用 Pinia):**
* 创建一个 `pomodoroStore` 来管理所有全局状态：
* `state`: (String) 当前状态，如 `'IDLE'`, `'RUNNING_WORK'`,
`'RUNNING_BREAK'`, `'PAUSED'`。
* `remainingTime`: (Number) 剩余秒数。
* `settings`: (Object) 用户的自定义设置 `{ work: 25, short: 5, long: 15,
theme: 'dark', autoCycle: false }`。
* `linkedTaskId`: (String | null) 当前关联的待办任务 ID。
* **用户流程 (User Flow - 关联任务):**
1. 用户在 `TodoPage.vue` 中点击某 `TaskItem.vue` 上的“开始专注”按钮。
2. 该按钮调用 `pomodoroStore` 的一个 action，如
`startFocusOnTask(taskId)`。
3. 这个 action 会设置 `linkedTaskId`，并将状态切换为 `'RUNNING_WORK'`，
开始倒计时。
4. `PomodoroWidget.vue` 监听到 store 的变化，自动更新其显示。
5. 当一个工作番茄钟完成，`pomodoroStore` 会触发一个 API 调用，将这个完成
记录发送到后端。
* **浏览器 API:**
* 使用 `setInterval()` 实现倒计时逻辑。
* 使用 `Notification.requestPermission()` 请求通知权限，并用 `new
Notification()` 发送通知。
* 使用 `new Audio()` 或 Web Audio API 播放提示音。
#### **后端 (Backend)**
* **API 接口 (API Endpoints):**
* `PUT /api/users/me/settings/pomodoro`: 更新当前用户的番茄钟设置。请求体
包含用户的所有自定义配置。
* `POST /api/pomodoro_logs`: 记录一个已完成的番茄钟。这是核心的数据记录
接口。
* **请求体 (JSON):**
```json
{
"task_id": "optional-task-uuid-12345", // 如果有关联任务，则提供任务
ID
"duration": 25 // 记录该番茄钟的实际时长（分钟）
}
```
* **数据模型 (Data Models):**

--- PAGE 13 ---

* `User` Model (**修改**):
* 添加一个 `pomodoro_settings` 字段 (推荐使用 `JSON` 类型)，用于存储 `
{ "work": 25, "short": 5, ... }` 等个性化配置。
* `PomodoroLog` (**新建**):
* `id`: 主键
* `user_id`: 外键 (关联 `User` 表)
* `task_id`: 外键 (可选，可为空，关联 `Task` 表)
* `completed_at`: 时间戳 (记录完成时间)
### **4. 技术栈建议 (Tech Stack Suggestion)**
* **前端:** **Vue.js 3** + **Pinia** (Pinia 对于管理计时器这种全局、复杂的状态至
关重要) + **Vite**
* **后端:** **Python** + **FastAPI**
* **数据库:** **SQLite** (或 PostgreSQL)
### **5. 开发步骤建议 (Development Steps)**
1. **后端基础搭建:**
* 修改 `User` 模型，增加 `pomodoro_settings` 字段。
* 创建 `PomodoroLog` 模型和相应的数据库表。
* 开发 `PUT /api/users/me/settings/pomodoro` 和 `POST /api/pomodoro_logs`
这两个 API 接口。
2. **前端核心逻辑:**
* 在 Pinia 中创建 `pomodoroStore`，实现纯粹的计时器逻辑（状态机、倒计时、
配置读取），先不涉及 UI。
3. **UI 开发与连接:**
* 创建 `PomodoroWidget.vue` 和 `FocusView.vue` 两个组件。
* 将这两个组件连接到 `pomodoroStore`，让它们能响应和展示计时器的实时状
态。
* 实现基本的开始、暂停、重置功能。
4. **设置与主题功能:**
* 开发 `PomodoroSettings.vue` 页面。
* 实现用户修改时长、开关自动流转等设置，并调用 API 保存到后端。
* 实现主题切换功能（初期可以只是简单的背景色切换）。
5. **与待办模块集成:**
* 在 `TaskItem.vue` 组件上添加“开始专注”按钮。
* 实现点击按钮后，调用 `pomodoroStore` 并传递 `taskId` 的逻辑。
6. **收尾工作 (提醒与日志):**
* 在番茄钟结束的逻辑中，加入播放声音和发送桌面通知的代码。
* 在工作番茄钟成功完成后，调用 `POST /api/pomodoro_logs` 接口，将记录保

--- PAGE 14 ---

存到数据库。
* (可选) 在任务详情页，调用后端接口，查询并显示该任务关联的
`PomodoroLog` 数量。
---
很好，这个想法极具前瞻性！我们正在从“工具集合”迈向“智能伙伴”。这完全符
合 “Cortex AI 工作区” 的核心理念。将项目管理与原生 AI 能力结合，意味着 AI 不
再是一个被动等待指令的聊天窗口，而是成为一个主动的、能理解目标的“项目经
理”。
你做出了非常棒的战略选择：
* **以终为始 (Option C):** 我们直接瞄准最具价值的“交互式 AI 规划”，这会成为
产品的核心亮点。
* **先集中后发散 (Kanban First)
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)